<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Stall and Flush Unit</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.16 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Stall and Flush Unit<br>
<small>
[<a class="el" href="group__pavr__hwres.html">Hardware resources</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
</table>
The pipeline controls its own stall and flush status, through specific stall and flush-related request signals. These requests are sent to the Stall and Flush Unit (SFU). The output of the SFU is a set of signals that directly control pipeline stages (a stall and flush control signals pair for each stage): <br>
 <br>
 <div align="center">
<img src="pavr_hwres_sfu_01.gif" alt="pavr_hwres_sfu_01.gif">
</div>
<br>
 <dl compact><dt><b>
Requests to SFU</b><dd>
<ul>
<li>stall requests <br>
 The SFU stalls <b>all</b> younger stages. However, by stalling-only, the current instruction is spawned into 2 instances. One of them must be killed (flushed). The the younger instance is killed (the previous stage is flushed). <br>
 Thus, a nop is introduced in the pipeline <b>before</b> the instruction wavefront. <br>
 If more than one stage request a stall at the same time, the older one has priority (the younger one will be stalled along with the others). Only after that, the younger one will be ackowledged its stall by means of appropriate stall and flush control signals. <br>
 Stall <b>requests</b>:<ul>
<li>pavr_s3_stall_rq <br>
<li>pavr_s5_stall_rq <br>
<li>pavr_s6_stall_rq</ul>
<li>flush requests <br>
 The SFU simply flushes that stage. <br>
 More than one flush could be acknolewdged at the same time, without competition. However, all flush requests happen to request to flush the same pipeline stage, s2. <br>
 Flush <b>requests</b>:<ul>
<li>pavr_s3_flush_s2_rq <br>
<li>pavr_s4_flush_s2_rq <br>
<li>pavr_s4_ret_flush_s2_rq <br>
<li>pavr_s5_ret_flush_s2_rq <br>
<li>pavr_s51_ret_flush_s2_rq <br>
<li>pavr_s52_ret_flush_s2_rq <br>
<li>pavr_s53_ret_flush_s2_rq <br>
<li>pavr_s54_ret_flush_s2_rq <br>
<li>pavr_s55_ret_flush_s2_rq <br>
</ul>
<li>branch requests <br>
 The SFU flushes stages s2...s5, because the corresponding instructions were already uselessly fetched, and requests the PC to be loaded with the branch relative jump address. <br>
 Branch <b>requests</b>:<ul>
<li>pavr_s6_branch_rq <br>
</ul>
<li>skip requests <br>
 The SFU treats skips as branches that have the relative jump address equal to 0, 1 or 2, depending on the skip condition and on next instruction's length (16/32 bits). <br>
 Skip <b>requests</b>:<ul>
<li>pavr_s6_skip_rq <br>
<li>pavr_s61_skip_rq</ul>
<li>nop requests <br>
 The SFU stalls all younger instructions. The current instruction is spawned into 2 instances. The older instance is killed (the very same stage that requested the nop stage is flushed). <br>
 Thus, a nop is introduced in the pipeline <b>after</b> the instruction wavefront. <br>
 In order to do that, a micro-state machine is needed outside the pipeline, because otherwise that stage would undefinitely stall itself. <br>
 Nop <b>requests</b>: <br>
<ul>
<li>pavr_s4_nop_rq <br>
 </ul>
</ul>
</dl><dl compact><dt><b>
SFU control signals</b><dd>
Each main pipeline stage (s1-s6) has 2 kinds of control signals, that are generated by the SFU: <ul>
<li> stall control <br>
 All registers in this stage are instructed to remain unchanged All possible requests to hardware resources (such as RF, IOF, BPU, DACU, SREG, etc) are reseted (to 0). <li> flush control <br>
 All registers in this stage are reseted (to 0), to a most "benign" state (a nop). Also, all requests to hardware resources are reseted. </ul>
<br>
 Each main pipeline stage has an associated flag that determines whether or not that stage has the right to access hardware resources. These flags are also managed by the SFU. <br>
 Hardware resources enabling flags:<ul>
<li>pavr_s1_hwrq_en<li>pavr_s2_hwrq_en<li>pavr_s3_hwrq_en<li>pavr_s4_hwrq_en<li>pavr_s5_hwrq_en<li>pavr_s6_hwrq_en </ul>
</dl><hr><address align="right"><small>Generated on Tue Dec 31 20:26:31 2002 for Pipelined AVR microcontroller by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.16 </small></address>
</body>
</html>
